{"question_id": "2788", "problem_slug": "design-cancellable-function", "problem_title": "Design Cancellable Function", "content": "Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function cancellable that accepts a generator object and returns an array of two values: a cancel function and a promise.\nYou may assume the generator function will only yield promises. It is your function's responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that error back to the generator.\nIf the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string \"Cancelled\" (Not an Error object). If the error was caught, the returned promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed.\nWhen the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error.\nAn example of how your code would be used:\n\nfunction* tasks() {\n  const val = yield new Promise(resolve => resolve(2 + 2));\n  yield new Promise(resolve => setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn't be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs \"Cancelled\" at t=50ms\n\nIf instead cancel() was not called or was called after t=100ms, the promise would have resolved 5.\n \nExample 1:\n\nInput: \ngeneratorFunction = function*() { \n  return 42; \n}\ncancelledAt = 100\nOutput: {\"resolved\": 42}\nExplanation:\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // resolves 42 at t=0ms\n\nThe generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.\n\nExample 2:\n\nInput:\ngeneratorFunction = function*() { \n  const msg = yield new Promise(res => res(\"Hello\")); \n  throw `Error: ${msg}`; \n}\ncancelledAt = null\nOutput: {\"rejected\": \"Error: Hello\"}\nExplanation:\nA promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.\n\nExample 3:\n\nInput: \ngeneratorFunction = function*() { \n  yield new Promise(res => setTimeout(res, 200)); \n  return \"Success\"; \n}\ncancelledAt = 100\nOutput: {\"rejected\": \"Cancelled\"}\nExplanation:\nWhile the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.\n\nExample 4:\n\nInput:\ngeneratorFunction = function*() { \n  let result = 0; \n  yield new Promise(res => setTimeout(res, 100));\n  result += yield new Promise(res => res(1)); \n  yield new Promise(res => setTimeout(res, 100)); \n  result += yield new Promise(res => res(1)); \n  return result;\n}\ncancelledAt = null\nOutput: {\"resolved\": 2}\nExplanation:\n4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.\n\nExample 5:\n\nInput: \ngeneratorFunction = function*() { \n  let result = 0; \n  try { \n    yield new Promise(res => setTimeout(res, 100)); \n    result += yield new Promise(res => res(1)); \n    yield new Promise(res => setTimeout(res, 100)); \n    result += yield new Promise(res => res(1)); \n  } catch(e) { \n    return result; \n  } \n  return result; \n}\ncancelledAt = 150\nOutput: {\"resolved\": 1}\nExplanation:\nThe first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.\n\nExample 6:\n\nInput: \ngeneratorFunction = function*() { \n  try { \n    yield new Promise((resolve, reject) => reject(\"Promise Rejected\")); \n  } catch(e) { \n    let a = yield new Promise(resolve => resolve(2));\n    let b = yield new Promise(resolve => resolve(2)); \n    return a + b; \n  }; \n}\ncancelledAt = null\nOutput: {\"resolved\": 4}\nExplanation:\nThe first yielded promise immediately rejects. This error is caught. Because the generator hasn't been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.\n \nConstraints:\n\ncancelledAt == null or 0 <= cancelledAt <= 1000\ngeneratorFunction returns a generator object\n\n", "hints": ["This question tests understanding of two-way communication between generator functions and the code that evaluates the generator. It is a powerful technique which is used in libraries such as redux-saga.", "You can pass a value value to a generator function X by calling generator.next(X). Then in the generator function, you can access this value by calling let X = yield \"val to pass into generator.next()\";", "You can throw an error back to a generator function by calling generator.throw(err). If this error isn't caught in the generator function, that will throw an error."], "exampleTestcases": "function*() { return 42; }\n{\"cancelledAt\":100}\nfunction*() { const msg = yield new Promise(res => res(\"Hello\")); throw `Error: ${msg}`; }\n{\"cancelledAt\":null}\nfunction*() { yield new Promise(res => setTimeout(res, 200)); return \"Success\"; }\n{\"cancelledAt\":100}\nfunction*() { let result = 0; yield new Promise(res => setTimeout(res, 100)); result += yield new Promise(res => res(1)); yield new Promise(res => setTimeout(res, 100)); result += yield new Promise(res => res(1)); return result; }\n{\"cancelledAt\":null}\nfunction*() { let result = 0; try { yield new Promise(res => setTimeout(res, 100)); result += yield new Promise(res => res(1)); yield new Promise(res => setTimeout(res, 100)); result += yield new Promise(res => res(1)); } catch(e) { return result; } return result; }\n{\"cancelledAt\":150}\nfunction*() { try { yield new Promise((resolve, reject) => reject(\"Promise Rejected\")); } catch(e) { let a = yield new Promise(resolve => resolve(2)); let b = yield new Promise(resolve => resolve(2)); return a + b; }; }\n{\"cancelledAt\":null}", "codeSnippets": {"JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {Generator} generator\n * @return {[Function, Promise]}\n */\nvar cancellable = function(generator) {\n    \n};\n\n/**\n * function* tasks() {\n *   const val = yield new Promise(resolve => resolve(2 + 2));\n *   yield new Promise(resolve => setTimeout(resolve, 100));\n *   return val + 1;\n * }\n * const [cancel, promise] = cancellable(tasks());\n * setTimeout(cancel, 50);\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\n */"}, "TypeScript": {"langSlug": "typescript", "code": "function cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\n    \n};\n\n/**\n * function* tasks() {\n *   const val = yield new Promise(resolve => resolve(2 + 2));\n *   yield new Promise(resolve => setTimeout(resolve, 100));\n *   return val + 1;\n * }\n * const [cancel, promise] = cancellable(tasks());\n * setTimeout(cancel, 50);\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\n */"}}}