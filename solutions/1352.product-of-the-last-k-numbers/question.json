{"questionId": "1477", "acRate": 51.96971304449792, "difficulty": "Medium", "freqBar": 34.113474178340816, "frontendQuestionId": "1352", "paidOnly": false, "status": "ac", "title": "Product of the Last K Numbers", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Math", "id": "VG9waWNUYWdOb2RlOjg=", "slug": "math"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}, {"name": "Queue", "id": "VG9waWNUYWdOb2RlOjM0", "slug": "queue"}, {"name": "Data Stream", "id": "VG9waWNUYWdOb2RlOjYxMDYz", "slug": "data-stream"}], "titleSlug": "product-of-the-last-k-numbers", "content": "<p>Design an algorithm that accepts a stream of integers and retrieves the product of the last <code>k</code> integers of the stream.</p>\n\n<p>Implement the <code>ProductOfNumbers</code> class:</p>\n\n<ul>\n\t<li><code>ProductOfNumbers()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void add(int num)</code> Appends the integer <code>num</code> to the stream.</li>\n\t<li><code>int getProduct(int k)</code> Returns the product of the last <code>k</code> numbers in the current list. You can assume that always the current list has at least <code>k</code> numbers.</li>\n</ul>\n\n<p>The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n<strong>Output</strong>\n[null,null,null,null,null,null,20,40,0,null,32]\n\n<strong>Explanation</strong>\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20\nproductOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li>At most <code>4 * 10<sup>4</sup></code> calls will be made to <code>add</code> and <code>getProduct</code>.</li>\n\t<li>The product of the stream at any point in time will fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n", "hints": ["Keep all prefix products of numbers in an array, then calculate the product of last K elements in O(1) complexity.", "When a zero number is added, clean the array of prefix products."], "exampleTestcases": "[\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class ProductOfNumbers {\npublic:\n    ProductOfNumbers() {\n        \n    }\n    \n    void add(int num) {\n        \n    }\n    \n    int getProduct(int k) {\n        \n    }\n};\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers* obj = new ProductOfNumbers();\n * obj->add(num);\n * int param_2 = obj->getProduct(k);\n */"}, {"lang": "Java", "langSlug": "java", "code": "class ProductOfNumbers {\n\n    public ProductOfNumbers() {\n        \n    }\n    \n    public void add(int num) {\n        \n    }\n    \n    public int getProduct(int k) {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = new ProductOfNumbers();\n * obj.add(num);\n * int param_2 = obj.getProduct(k);\n */"}, {"lang": "Python", "langSlug": "python", "code": "class ProductOfNumbers(object):\n\n    def __init__(self):\n        \n\n    def add(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getProduct(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)"}, {"lang": "Python3", "langSlug": "python3", "code": "class ProductOfNumbers:\n\n    def __init__(self):\n        \n\n    def add(self, num: int) -> None:\n        \n\n    def getProduct(self, k: int) -> int:\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} ProductOfNumbers;\n\n\nProductOfNumbers* productOfNumbersCreate() {\n    \n}\n\nvoid productOfNumbersAdd(ProductOfNumbers* obj, int num) {\n    \n}\n\nint productOfNumbersGetProduct(ProductOfNumbers* obj, int k) {\n    \n}\n\nvoid productOfNumbersFree(ProductOfNumbers* obj) {\n    \n}\n\n/**\n * Your ProductOfNumbers struct will be instantiated and called as such:\n * ProductOfNumbers* obj = productOfNumbersCreate();\n * productOfNumbersAdd(obj, num);\n \n * int param_2 = productOfNumbersGetProduct(obj, k);\n \n * productOfNumbersFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class ProductOfNumbers {\n\n    public ProductOfNumbers() {\n        \n    }\n    \n    public void Add(int num) {\n        \n    }\n    \n    public int GetProduct(int k) {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = new ProductOfNumbers();\n * obj.Add(num);\n * int param_2 = obj.GetProduct(k);\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "\nvar ProductOfNumbers = function() {\n    \n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nProductOfNumbers.prototype.add = function(num) {\n    \n};\n\n/** \n * @param {number} k\n * @return {number}\n */\nProductOfNumbers.prototype.getProduct = function(k) {\n    \n};\n\n/** \n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = new ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class ProductOfNumbers {\n    constructor() {\n        \n    }\n\n    add(num: number): void {\n        \n    }\n\n    getProduct(k: number): number {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = new ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class ProductOfNumbers {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $num\n     * @return NULL\n     */\n    function add($num) {\n        \n    }\n  \n    /**\n     * @param Integer $k\n     * @return Integer\n     */\n    function getProduct($k) {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * $obj = ProductOfNumbers();\n * $obj->add($num);\n * $ret_2 = $obj->getProduct($k);\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass ProductOfNumbers {\n\n    init() {\n        \n    }\n    \n    func add(_ num: Int) {\n        \n    }\n    \n    func getProduct(_ k: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * let obj = ProductOfNumbers()\n * obj.add(num)\n * let ret_2: Int = obj.getProduct(k)\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class ProductOfNumbers() {\n\n    fun add(num: Int) {\n        \n    }\n\n    fun getProduct(k: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class ProductOfNumbers {\n\n  ProductOfNumbers() {\n    \n  }\n  \n  void add(int num) {\n    \n  }\n  \n  int getProduct(int k) {\n    \n  }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = ProductOfNumbers();\n * obj.add(num);\n * int param2 = obj.getProduct(k);\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type ProductOfNumbers struct {\n    \n}\n\n\nfunc Constructor() ProductOfNumbers {\n    \n}\n\n\nfunc (this *ProductOfNumbers) Add(num int)  {\n    \n}\n\n\nfunc (this *ProductOfNumbers) GetProduct(k int) int {\n    \n}\n\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(num);\n * param_2 := obj.GetProduct(k);\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class ProductOfNumbers\n    def initialize()\n        \n    end\n\n\n=begin\n    :type num: Integer\n    :rtype: Void\n=end\n    def add(num)\n        \n    end\n\n\n=begin\n    :type k: Integer\n    :rtype: Integer\n=end\n    def get_product(k)\n        \n    end\n\n\nend\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers.new()\n# obj.add(num)\n# param_2 = obj.get_product(k)"}, {"lang": "Scala", "langSlug": "scala", "code": "class ProductOfNumbers() {\n\n    def add(num: Int): Unit = {\n        \n    }\n\n    def getProduct(k: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * val obj = new ProductOfNumbers()\n * obj.add(num)\n * val param_2 = obj.getProduct(k)\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct ProductOfNumbers {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ProductOfNumbers {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, num: i32) {\n        \n    }\n    \n    fn get_product(&self, k: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * let obj = ProductOfNumbers::new();\n * obj.add(num);\n * let ret_2: i32 = obj.get_product(k);\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define product-of-numbers%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add num)\n      )\n    ; get-product : exact-integer? -> exact-integer?\n    (define/public (get-product k)\n      )))\n\n;; Your product-of-numbers% object will be instantiated and called as such:\n;; (define obj (new product-of-numbers%))\n;; (send obj add num)\n;; (define param_2 (send obj get-product k))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec product_of_numbers_init_() -> any().\nproduct_of_numbers_init_() ->\n  .\n\n-spec product_of_numbers_add(Num :: integer()) -> any().\nproduct_of_numbers_add(Num) ->\n  .\n\n-spec product_of_numbers_get_product(K :: integer()) -> integer().\nproduct_of_numbers_get_product(K) ->\n  .\n\n\n%% Your functions will be called as such:\n%% product_of_numbers_init_(),\n%% product_of_numbers_add(Num),\n%% Param_2 = product_of_numbers_get_product(K),\n\n%% product_of_numbers_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule ProductOfNumbers do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(num :: integer) :: any\n  def add(num) do\n    \n  end\n\n  @spec get_product(k :: integer) :: integer\n  def get_product(k) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ProductOfNumbers.init_()\n# ProductOfNumbers.add(num)\n# param_2 = ProductOfNumbers.get_product(k)\n\n# ProductOfNumbers.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": []}