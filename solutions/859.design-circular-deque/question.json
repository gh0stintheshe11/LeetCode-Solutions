{"question_id": "859", "problem_slug": "design-circular-deque", "problem_title": "Design Circular Deque", "content": "Design your implementation of the circular double-ended queue (deque).\nImplement the MyCircularDeque class:\n\nMyCircularDeque(int k) Initializes the deque with a maximum size of k.\nboolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.\nboolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.\nboolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.\nboolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.\nint getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.\nint getRear() Returns the last item from Deque. Returns -1 if the deque is empty.\nboolean isEmpty() Returns true if the deque is empty, or false otherwise.\nboolean isFull() Returns true if the deque is full, or false otherwise.\n\n \nExample 1:\n\nInput\n[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\nOutput\n[null, true, true, true, false, 2, true, true, true, 4]\n\nExplanation\nMyCircularDeque myCircularDeque = new MyCircularDeque(3);\nmyCircularDeque.insertLast(1);  // return True\nmyCircularDeque.insertLast(2);  // return True\nmyCircularDeque.insertFront(3); // return True\nmyCircularDeque.insertFront(4); // return False, the queue is full.\nmyCircularDeque.getRear();      // return 2\nmyCircularDeque.isFull();       // return True\nmyCircularDeque.deleteLast();   // return True\nmyCircularDeque.insertFront(4); // return True\nmyCircularDeque.getFront();     // return 4\n\n \nConstraints:\n\n1 <= k <= 1000\n0 <= value <= 1000\nAt most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\n", "hints": [], "exampleTestcases": "[\"MyCircularDeque\",\"insertLast\",\"insertLast\",\"insertFront\",\"insertFront\",\"getRear\",\"isFull\",\"deleteLast\",\"insertFront\",\"getFront\"]\n[[3],[1],[2],[3],[4],[],[],[],[4],[]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class MyCircularDeque {\npublic:\n    MyCircularDeque(int k) {\n        \n    }\n    \n    bool insertFront(int value) {\n        \n    }\n    \n    bool insertLast(int value) {\n        \n    }\n    \n    bool deleteFront() {\n        \n    }\n    \n    bool deleteLast() {\n        \n    }\n    \n    int getFront() {\n        \n    }\n    \n    int getRear() {\n        \n    }\n    \n    bool isEmpty() {\n        \n    }\n    \n    bool isFull() {\n        \n    }\n};\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque* obj = new MyCircularDeque(k);\n * bool param_1 = obj->insertFront(value);\n * bool param_2 = obj->insertLast(value);\n * bool param_3 = obj->deleteFront();\n * bool param_4 = obj->deleteLast();\n * int param_5 = obj->getFront();\n * int param_6 = obj->getRear();\n * bool param_7 = obj->isEmpty();\n * bool param_8 = obj->isFull();\n */"}, "Java": {"langSlug": "java", "code": "class MyCircularDeque {\n\n    public MyCircularDeque(int k) {\n        \n    }\n    \n    public boolean insertFront(int value) {\n        \n    }\n    \n    public boolean insertLast(int value) {\n        \n    }\n    \n    public boolean deleteFront() {\n        \n    }\n    \n    public boolean deleteLast() {\n        \n    }\n    \n    public int getFront() {\n        \n    }\n    \n    public int getRear() {\n        \n    }\n    \n    public boolean isEmpty() {\n        \n    }\n    \n    public boolean isFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque obj = new MyCircularDeque(k);\n * boolean param_1 = obj.insertFront(value);\n * boolean param_2 = obj.insertLast(value);\n * boolean param_3 = obj.deleteFront();\n * boolean param_4 = obj.deleteLast();\n * int param_5 = obj.getFront();\n * int param_6 = obj.getRear();\n * boolean param_7 = obj.isEmpty();\n * boolean param_8 = obj.isFull();\n */"}, "Python": {"langSlug": "python", "code": "class MyCircularDeque(object):\n\n    def __init__(self, k):\n        \"\"\"\n        :type k: int\n        \"\"\"\n        \n\n    def insertFront(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def insertLast(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def deleteFront(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def deleteLast(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def getFront(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def getRear(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def isEmpty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def isFull(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque(k)\n# param_1 = obj.insertFront(value)\n# param_2 = obj.insertLast(value)\n# param_3 = obj.deleteFront()\n# param_4 = obj.deleteLast()\n# param_5 = obj.getFront()\n# param_6 = obj.getRear()\n# param_7 = obj.isEmpty()\n# param_8 = obj.isFull()"}, "Python3": {"langSlug": "python3", "code": "class MyCircularDeque:\n\n    def __init__(self, k: int):\n        \n\n    def insertFront(self, value: int) -> bool:\n        \n\n    def insertLast(self, value: int) -> bool:\n        \n\n    def deleteFront(self) -> bool:\n        \n\n    def deleteLast(self) -> bool:\n        \n\n    def getFront(self) -> int:\n        \n\n    def getRear(self) -> int:\n        \n\n    def isEmpty(self) -> bool:\n        \n\n    def isFull(self) -> bool:\n        \n\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque(k)\n# param_1 = obj.insertFront(value)\n# param_2 = obj.insertLast(value)\n# param_3 = obj.deleteFront()\n# param_4 = obj.deleteLast()\n# param_5 = obj.getFront()\n# param_6 = obj.getRear()\n# param_7 = obj.isEmpty()\n# param_8 = obj.isFull()"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} MyCircularDeque;\n\n\nMyCircularDeque* myCircularDequeCreate(int k) {\n    \n}\n\nbool myCircularDequeInsertFront(MyCircularDeque* obj, int value) {\n    \n}\n\nbool myCircularDequeInsertLast(MyCircularDeque* obj, int value) {\n    \n}\n\nbool myCircularDequeDeleteFront(MyCircularDeque* obj) {\n    \n}\n\nbool myCircularDequeDeleteLast(MyCircularDeque* obj) {\n    \n}\n\nint myCircularDequeGetFront(MyCircularDeque* obj) {\n    \n}\n\nint myCircularDequeGetRear(MyCircularDeque* obj) {\n    \n}\n\nbool myCircularDequeIsEmpty(MyCircularDeque* obj) {\n    \n}\n\nbool myCircularDequeIsFull(MyCircularDeque* obj) {\n    \n}\n\nvoid myCircularDequeFree(MyCircularDeque* obj) {\n    \n}\n\n/**\n * Your MyCircularDeque struct will be instantiated and called as such:\n * MyCircularDeque* obj = myCircularDequeCreate(k);\n * bool param_1 = myCircularDequeInsertFront(obj, value);\n \n * bool param_2 = myCircularDequeInsertLast(obj, value);\n \n * bool param_3 = myCircularDequeDeleteFront(obj);\n \n * bool param_4 = myCircularDequeDeleteLast(obj);\n \n * int param_5 = myCircularDequeGetFront(obj);\n \n * int param_6 = myCircularDequeGetRear(obj);\n \n * bool param_7 = myCircularDequeIsEmpty(obj);\n \n * bool param_8 = myCircularDequeIsFull(obj);\n \n * myCircularDequeFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class MyCircularDeque {\n\n    public MyCircularDeque(int k) {\n        \n    }\n    \n    public bool InsertFront(int value) {\n        \n    }\n    \n    public bool InsertLast(int value) {\n        \n    }\n    \n    public bool DeleteFront() {\n        \n    }\n    \n    public bool DeleteLast() {\n        \n    }\n    \n    public int GetFront() {\n        \n    }\n    \n    public int GetRear() {\n        \n    }\n    \n    public bool IsEmpty() {\n        \n    }\n    \n    public bool IsFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque obj = new MyCircularDeque(k);\n * bool param_1 = obj.InsertFront(value);\n * bool param_2 = obj.InsertLast(value);\n * bool param_3 = obj.DeleteFront();\n * bool param_4 = obj.DeleteLast();\n * int param_5 = obj.GetFront();\n * int param_6 = obj.GetRear();\n * bool param_7 = obj.IsEmpty();\n * bool param_8 = obj.IsFull();\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} k\n */\nvar MyCircularDeque = function(k) {\n    \n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nMyCircularDeque.prototype.insertFront = function(value) {\n    \n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nMyCircularDeque.prototype.insertLast = function(value) {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.deleteFront = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.deleteLast = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyCircularDeque.prototype.getFront = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyCircularDeque.prototype.getRear = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.isEmpty = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.isFull = function() {\n    \n};\n\n/** \n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = new MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class MyCircularDeque {\n    constructor(k: number) {\n        \n    }\n\n    insertFront(value: number): boolean {\n        \n    }\n\n    insertLast(value: number): boolean {\n        \n    }\n\n    deleteFront(): boolean {\n        \n    }\n\n    deleteLast(): boolean {\n        \n    }\n\n    getFront(): number {\n        \n    }\n\n    getRear(): number {\n        \n    }\n\n    isEmpty(): boolean {\n        \n    }\n\n    isFull(): boolean {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = new MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */"}, "PHP": {"langSlug": "php", "code": "class MyCircularDeque {\n    /**\n     * @param Integer $k\n     */\n    function __construct($k) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Boolean\n     */\n    function insertFront($value) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Boolean\n     */\n    function insertLast($value) {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function deleteFront() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function deleteLast() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function getFront() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function getRear() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function isEmpty() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function isFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * $obj = MyCircularDeque($k);\n * $ret_1 = $obj->insertFront($value);\n * $ret_2 = $obj->insertLast($value);\n * $ret_3 = $obj->deleteFront();\n * $ret_4 = $obj->deleteLast();\n * $ret_5 = $obj->getFront();\n * $ret_6 = $obj->getRear();\n * $ret_7 = $obj->isEmpty();\n * $ret_8 = $obj->isFull();\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass MyCircularDeque {\n\n    init(_ k: Int) {\n        \n    }\n    \n    func insertFront(_ value: Int) -> Bool {\n        \n    }\n    \n    func insertLast(_ value: Int) -> Bool {\n        \n    }\n    \n    func deleteFront() -> Bool {\n        \n    }\n    \n    func deleteLast() -> Bool {\n        \n    }\n    \n    func getFront() -> Int {\n        \n    }\n    \n    func getRear() -> Int {\n        \n    }\n    \n    func isEmpty() -> Bool {\n        \n    }\n    \n    func isFull() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * let obj = MyCircularDeque(k)\n * let ret_1: Bool = obj.insertFront(value)\n * let ret_2: Bool = obj.insertLast(value)\n * let ret_3: Bool = obj.deleteFront()\n * let ret_4: Bool = obj.deleteLast()\n * let ret_5: Int = obj.getFront()\n * let ret_6: Int = obj.getRear()\n * let ret_7: Bool = obj.isEmpty()\n * let ret_8: Bool = obj.isFull()\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class MyCircularDeque(k: Int) {\n\n    fun insertFront(value: Int): Boolean {\n        \n    }\n\n    fun insertLast(value: Int): Boolean {\n        \n    }\n\n    fun deleteFront(): Boolean {\n        \n    }\n\n    fun deleteLast(): Boolean {\n        \n    }\n\n    fun getFront(): Int {\n        \n    }\n\n    fun getRear(): Int {\n        \n    }\n\n    fun isEmpty(): Boolean {\n        \n    }\n\n    fun isFull(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */"}, "Dart": {"langSlug": "dart", "code": "class MyCircularDeque {\n\n  MyCircularDeque(int k) {\n    \n  }\n  \n  bool insertFront(int value) {\n    \n  }\n  \n  bool insertLast(int value) {\n    \n  }\n  \n  bool deleteFront() {\n    \n  }\n  \n  bool deleteLast() {\n    \n  }\n  \n  int getFront() {\n    \n  }\n  \n  int getRear() {\n    \n  }\n  \n  bool isEmpty() {\n    \n  }\n  \n  bool isFull() {\n    \n  }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque obj = MyCircularDeque(k);\n * bool param1 = obj.insertFront(value);\n * bool param2 = obj.insertLast(value);\n * bool param3 = obj.deleteFront();\n * bool param4 = obj.deleteLast();\n * int param5 = obj.getFront();\n * int param6 = obj.getRear();\n * bool param7 = obj.isEmpty();\n * bool param8 = obj.isFull();\n */"}, "Go": {"langSlug": "golang", "code": "type MyCircularDeque struct {\n    \n}\n\n\nfunc Constructor(k int) MyCircularDeque {\n    \n}\n\n\nfunc (this *MyCircularDeque) InsertFront(value int) bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) InsertLast(value int) bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) DeleteFront() bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) DeleteLast() bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) GetFront() int {\n    \n}\n\n\nfunc (this *MyCircularDeque) GetRear() int {\n    \n}\n\n\nfunc (this *MyCircularDeque) IsEmpty() bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) IsFull() bool {\n    \n}\n\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.InsertFront(value);\n * param_2 := obj.InsertLast(value);\n * param_3 := obj.DeleteFront();\n * param_4 := obj.DeleteLast();\n * param_5 := obj.GetFront();\n * param_6 := obj.GetRear();\n * param_7 := obj.IsEmpty();\n * param_8 := obj.IsFull();\n */"}, "Ruby": {"langSlug": "ruby", "code": "class MyCircularDeque\n\n=begin\n    :type k: Integer\n=end\n    def initialize(k)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def insert_front(value)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def insert_last(value)\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def delete_front()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def delete_last()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def get_front()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def get_rear()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def is_empty()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def is_full()\n        \n    end\n\n\nend\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque.new(k)\n# param_1 = obj.insert_front(value)\n# param_2 = obj.insert_last(value)\n# param_3 = obj.delete_front()\n# param_4 = obj.delete_last()\n# param_5 = obj.get_front()\n# param_6 = obj.get_rear()\n# param_7 = obj.is_empty()\n# param_8 = obj.is_full()"}, "Scala": {"langSlug": "scala", "code": "class MyCircularDeque(_k: Int) {\n\n    def insertFront(value: Int): Boolean = {\n        \n    }\n\n    def insertLast(value: Int): Boolean = {\n        \n    }\n\n    def deleteFront(): Boolean = {\n        \n    }\n\n    def deleteLast(): Boolean = {\n        \n    }\n\n    def getFront(): Int = {\n        \n    }\n\n    def getRear(): Int = {\n        \n    }\n\n    def isEmpty(): Boolean = {\n        \n    }\n\n    def isFull(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * val obj = new MyCircularDeque(k)\n * val param_1 = obj.insertFront(value)\n * val param_2 = obj.insertLast(value)\n * val param_3 = obj.deleteFront()\n * val param_4 = obj.deleteLast()\n * val param_5 = obj.getFront()\n * val param_6 = obj.getRear()\n * val param_7 = obj.isEmpty()\n * val param_8 = obj.isFull()\n */"}, "Rust": {"langSlug": "rust", "code": "struct MyCircularDeque {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyCircularDeque {\n\n    fn new(k: i32) -> Self {\n        \n    }\n    \n    fn insert_front(&self, value: i32) -> bool {\n        \n    }\n    \n    fn insert_last(&self, value: i32) -> bool {\n        \n    }\n    \n    fn delete_front(&self) -> bool {\n        \n    }\n    \n    fn delete_last(&self) -> bool {\n        \n    }\n    \n    fn get_front(&self) -> i32 {\n        \n    }\n    \n    fn get_rear(&self) -> i32 {\n        \n    }\n    \n    fn is_empty(&self) -> bool {\n        \n    }\n    \n    fn is_full(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * let obj = MyCircularDeque::new(k);\n * let ret_1: bool = obj.insert_front(value);\n * let ret_2: bool = obj.insert_last(value);\n * let ret_3: bool = obj.delete_front();\n * let ret_4: bool = obj.delete_last();\n * let ret_5: i32 = obj.get_front();\n * let ret_6: i32 = obj.get_rear();\n * let ret_7: bool = obj.is_empty();\n * let ret_8: bool = obj.is_full();\n */"}, "Racket": {"langSlug": "racket", "code": "(define my-circular-deque%\n  (class object%\n    (super-new)\n    \n    ; k : exact-integer?\n    (init-field\n      k)\n    \n    ; insert-front : exact-integer? -> boolean?\n    (define/public (insert-front value)\n      )\n    ; insert-last : exact-integer? -> boolean?\n    (define/public (insert-last value)\n      )\n    ; delete-front : -> boolean?\n    (define/public (delete-front)\n      )\n    ; delete-last : -> boolean?\n    (define/public (delete-last)\n      )\n    ; get-front : -> exact-integer?\n    (define/public (get-front)\n      )\n    ; get-rear : -> exact-integer?\n    (define/public (get-rear)\n      )\n    ; is-empty : -> boolean?\n    (define/public (is-empty)\n      )\n    ; is-full : -> boolean?\n    (define/public (is-full)\n      )))\n\n;; Your my-circular-deque% object will be instantiated and called as such:\n;; (define obj (new my-circular-deque% [k k]))\n;; (define param_1 (send obj insert-front value))\n;; (define param_2 (send obj insert-last value))\n;; (define param_3 (send obj delete-front))\n;; (define param_4 (send obj delete-last))\n;; (define param_5 (send obj get-front))\n;; (define param_6 (send obj get-rear))\n;; (define param_7 (send obj is-empty))\n;; (define param_8 (send obj is-full))"}, "Erlang": {"langSlug": "erlang", "code": "-spec my_circular_deque_init_(K :: integer()) -> any().\nmy_circular_deque_init_(K) ->\n  .\n\n-spec my_circular_deque_insert_front(Value :: integer()) -> boolean().\nmy_circular_deque_insert_front(Value) ->\n  .\n\n-spec my_circular_deque_insert_last(Value :: integer()) -> boolean().\nmy_circular_deque_insert_last(Value) ->\n  .\n\n-spec my_circular_deque_delete_front() -> boolean().\nmy_circular_deque_delete_front() ->\n  .\n\n-spec my_circular_deque_delete_last() -> boolean().\nmy_circular_deque_delete_last() ->\n  .\n\n-spec my_circular_deque_get_front() -> integer().\nmy_circular_deque_get_front() ->\n  .\n\n-spec my_circular_deque_get_rear() -> integer().\nmy_circular_deque_get_rear() ->\n  .\n\n-spec my_circular_deque_is_empty() -> boolean().\nmy_circular_deque_is_empty() ->\n  .\n\n-spec my_circular_deque_is_full() -> boolean().\nmy_circular_deque_is_full() ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_circular_deque_init_(K),\n%% Param_1 = my_circular_deque_insert_front(Value),\n%% Param_2 = my_circular_deque_insert_last(Value),\n%% Param_3 = my_circular_deque_delete_front(),\n%% Param_4 = my_circular_deque_delete_last(),\n%% Param_5 = my_circular_deque_get_front(),\n%% Param_6 = my_circular_deque_get_rear(),\n%% Param_7 = my_circular_deque_is_empty(),\n%% Param_8 = my_circular_deque_is_full(),\n\n%% my_circular_deque_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule MyCircularDeque do\n  @spec init_(k :: integer) :: any\n  def init_(k) do\n    \n  end\n\n  @spec insert_front(value :: integer) :: boolean\n  def insert_front(value) do\n    \n  end\n\n  @spec insert_last(value :: integer) :: boolean\n  def insert_last(value) do\n    \n  end\n\n  @spec delete_front() :: boolean\n  def delete_front() do\n    \n  end\n\n  @spec delete_last() :: boolean\n  def delete_last() do\n    \n  end\n\n  @spec get_front() :: integer\n  def get_front() do\n    \n  end\n\n  @spec get_rear() :: integer\n  def get_rear() do\n    \n  end\n\n  @spec is_empty() :: boolean\n  def is_empty() do\n    \n  end\n\n  @spec is_full() :: boolean\n  def is_full() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MyCircularDeque.init_(k)\n# param_1 = MyCircularDeque.insert_front(value)\n# param_2 = MyCircularDeque.insert_last(value)\n# param_3 = MyCircularDeque.delete_front()\n# param_4 = MyCircularDeque.delete_last()\n# param_5 = MyCircularDeque.get_front()\n# param_6 = MyCircularDeque.get_rear()\n# param_7 = MyCircularDeque.is_empty()\n# param_8 = MyCircularDeque.is_full()\n\n# MyCircularDeque.init_ will be called before every test case, in which you can do some necessary initializations."}}}