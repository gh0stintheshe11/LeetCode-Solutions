{"question_id": "1296", "problem_slug": "kth-ancestor-of-a-tree-node", "problem_title": "Kth Ancestor of a Tree Node", "content": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.\n\n \nExample 1:\n\n\nInput\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor\n \nConstraints:\n\n1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.\n\n", "hints": ["The queries must be answered efficiently to avoid time limit exceeded verdict.", "Use sparse table (dynamic programming application) to travel the tree upwards in a fast way."], "exampleTestcases": "[\"TreeAncestor\",\"getKthAncestor\",\"getKthAncestor\",\"getKthAncestor\"]\n[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class TreeAncestor {\npublic:\n    TreeAncestor(int n, vector<int>& parent) {\n        \n    }\n    \n    int getKthAncestor(int node, int k) {\n        \n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */"}, "Java": {"langSlug": "java", "code": "class TreeAncestor {\n\n    public TreeAncestor(int n, int[] parent) {\n        \n    }\n    \n    public int getKthAncestor(int node, int k) {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor obj = new TreeAncestor(n, parent);\n * int param_1 = obj.getKthAncestor(node,k);\n */"}, "Python": {"langSlug": "python", "code": "class TreeAncestor(object):\n\n    def __init__(self, n, parent):\n        \"\"\"\n        :type n: int\n        :type parent: List[int]\n        \"\"\"\n        \n\n    def getKthAncestor(self, node, k):\n        \"\"\"\n        :type node: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor(n, parent)\n# param_1 = obj.getKthAncestor(node,k)"}, "Python3": {"langSlug": "python3", "code": "class TreeAncestor:\n\n    def __init__(self, n: int, parent: List[int]):\n        \n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        \n\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor(n, parent)\n# param_1 = obj.getKthAncestor(node,k)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} TreeAncestor;\n\n\nTreeAncestor* treeAncestorCreate(int n, int* parent, int parentSize) {\n    \n}\n\nint treeAncestorGetKthAncestor(TreeAncestor* obj, int node, int k) {\n    \n}\n\nvoid treeAncestorFree(TreeAncestor* obj) {\n    \n}\n\n/**\n * Your TreeAncestor struct will be instantiated and called as such:\n * TreeAncestor* obj = treeAncestorCreate(n, parent, parentSize);\n * int param_1 = treeAncestorGetKthAncestor(obj, node, k);\n \n * treeAncestorFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class TreeAncestor {\n\n    public TreeAncestor(int n, int[] parent) {\n        \n    }\n    \n    public int GetKthAncestor(int node, int k) {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor obj = new TreeAncestor(n, parent);\n * int param_1 = obj.GetKthAncestor(node,k);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[]} parent\n */\nvar TreeAncestor = function(n, parent) {\n    \n};\n\n/** \n * @param {number} node \n * @param {number} k\n * @return {number}\n */\nTreeAncestor.prototype.getKthAncestor = function(node, k) {\n    \n};\n\n/** \n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = new TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class TreeAncestor {\n    constructor(n: number, parent: number[]) {\n        \n    }\n\n    getKthAncestor(node: number, k: number): number {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = new TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */"}, "PHP": {"langSlug": "php", "code": "class TreeAncestor {\n    /**\n     * @param Integer $n\n     * @param Integer[] $parent\n     */\n    function __construct($n, $parent) {\n        \n    }\n  \n    /**\n     * @param Integer $node\n     * @param Integer $k\n     * @return Integer\n     */\n    function getKthAncestor($node, $k) {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * $obj = TreeAncestor($n, $parent);\n * $ret_1 = $obj->getKthAncestor($node, $k);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass TreeAncestor {\n\n    init(_ n: Int, _ parent: [Int]) {\n        \n    }\n    \n    func getKthAncestor(_ node: Int, _ k: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * let obj = TreeAncestor(n, parent)\n * let ret_1: Int = obj.getKthAncestor(node, k)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class TreeAncestor(n: Int, parent: IntArray) {\n\n    fun getKthAncestor(node: Int, k: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */"}, "Dart": {"langSlug": "dart", "code": "class TreeAncestor {\n\n  TreeAncestor(int n, List<int> parent) {\n    \n  }\n  \n  int getKthAncestor(int node, int k) {\n    \n  }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor obj = TreeAncestor(n, parent);\n * int param1 = obj.getKthAncestor(node,k);\n */"}, "Go": {"langSlug": "golang", "code": "type TreeAncestor struct {\n    \n}\n\n\nfunc Constructor(n int, parent []int) TreeAncestor {\n    \n}\n\n\nfunc (this *TreeAncestor) GetKthAncestor(node int, k int) int {\n    \n}\n\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * obj := Constructor(n, parent);\n * param_1 := obj.GetKthAncestor(node,k);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class TreeAncestor\n\n=begin\n    :type n: Integer\n    :type parent: Integer[]\n=end\n    def initialize(n, parent)\n        \n    end\n\n\n=begin\n    :type node: Integer\n    :type k: Integer\n    :rtype: Integer\n=end\n    def get_kth_ancestor(node, k)\n        \n    end\n\n\nend\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor.new(n, parent)\n# param_1 = obj.get_kth_ancestor(node, k)"}, "Scala": {"langSlug": "scala", "code": "class TreeAncestor(_n: Int, _parent: Array[Int]) {\n\n    def getKthAncestor(node: Int, k: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * val obj = new TreeAncestor(n, parent)\n * val param_1 = obj.getKthAncestor(node,k)\n */"}, "Rust": {"langSlug": "rust", "code": "struct TreeAncestor {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl TreeAncestor {\n\n    fn new(n: i32, parent: Vec<i32>) -> Self {\n        \n    }\n    \n    fn get_kth_ancestor(&self, node: i32, k: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * let obj = TreeAncestor::new(n, parent);\n * let ret_1: i32 = obj.get_kth_ancestor(node, k);\n */"}, "Racket": {"langSlug": "racket", "code": "(define tree-ancestor%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; parent : (listof exact-integer?)\n    (init-field\n      n\n      parent)\n    \n    ; get-kth-ancestor : exact-integer? exact-integer? -> exact-integer?\n    (define/public (get-kth-ancestor node k)\n      )))\n\n;; Your tree-ancestor% object will be instantiated and called as such:\n;; (define obj (new tree-ancestor% [n n] [parent parent]))\n;; (define param_1 (send obj get-kth-ancestor node k))"}, "Erlang": {"langSlug": "erlang", "code": "-spec tree_ancestor_init_(N :: integer(), Parent :: [integer()]) -> any().\ntree_ancestor_init_(N, Parent) ->\n  .\n\n-spec tree_ancestor_get_kth_ancestor(Node :: integer(), K :: integer()) -> integer().\ntree_ancestor_get_kth_ancestor(Node, K) ->\n  .\n\n\n%% Your functions will be called as such:\n%% tree_ancestor_init_(N, Parent),\n%% Param_1 = tree_ancestor_get_kth_ancestor(Node, K),\n\n%% tree_ancestor_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule TreeAncestor do\n  @spec init_(n :: integer, parent :: [integer]) :: any\n  def init_(n, parent) do\n    \n  end\n\n  @spec get_kth_ancestor(node :: integer, k :: integer) :: integer\n  def get_kth_ancestor(node, k) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# TreeAncestor.init_(n, parent)\n# param_1 = TreeAncestor.get_kth_ancestor(node, k)\n\n# TreeAncestor.init_ will be called before every test case, in which you can do some necessary initializations."}}}